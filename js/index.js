// Generated by CoffeeScript 2.3.0
var fs, path, wch;

path = require('path');

wch = require('wch');

fs = require('fsx');

// TODO: source maps
// TODO: use desired typescript version per package
module.exports = function(log) {
  var build, clear, compile, shortPath, ts, watchOptions;
  ts = require('typescript');
  shortPath = function(path) {
    return path.replace(process.env.HOME, '~');
  };
  compile = function(file) {
    var err, mtime, program, source;
    try {
      mtime = fs.stat(file.dest).mtime.getTime();
    } catch (error) {}
    if (mtime && mtime > file.mtime_ms) {
      return;
    }
    log('Transpiling:', shortPath(file.path));
    try {
      program = ts.createProgram([file.path], this.config);
      source = program.getSourceFile(file.path);
      program.emit(source);
      if (this.config.declaration) {
        program.emit(source, null, null, true);
      }
      return file;
    } catch (error) {
      err = error;
      log(log.red('Failed to compile:'), shortPath(file.path));
      log(err.stack);
    }
  };
  build = wch.pipeline().map(compile).each(function(file) {
    return file && wch.emit('file:build', {
      file: file.path,
      dest: file.dest
    });
  });
  clear = wch.pipeline().delete(function(file) {
    return file.dest;
  }).each(function(dest, file) {
    return wch.emit('file:delete', {
      file: file.path,
      dest
    });
  });
  watchOptions = {
    only: ['*.ts'],
    skip: ['**/__*__/**'],
    fields: ['name', 'exists', 'new', 'mtime_ms'],
    crawl: true
  };
  return {
    attach: function(pack) {
      var cfgPath, dest, onChange, roots, tsconfig;
      if (!pack.main) {
        log.warn(`Missing 'main' field: ${shortPath(pack.path)}`);
        return;
      }
      cfgPath = path.join(pack.path, 'tsconfig.json');
      if (!fs.isFile(cfgPath)) {
        log.warn(`Missing 'tsconfig.json' file: ${shortPath(pack.path)}`);
        return;
      }
      pack.config = tsconfig = require(cfgPath).compilerOptions || {};
      dest = tsconfig.outDir || path.dirname(path.join(pack.path, pack.main));
      tsconfig.outDir || (tsconfig.outDir = dest);
      tsconfig.noResolve = true;
      tsconfig.isolatedModules = true;
      delete tsconfig.moduleResolution;
      roots = tsconfig.rootDirs || [tsconfig.rootDir];
      if (roots[0] === void 0) {
        log.warn(`Missing 'rootDir' or 'rootDirs' option: ${shortPath(cfgPath)}`);
        return;
      }
      onChange = async function(file) {
        var action, err;
        file.dest = path.join(dest, file.name.replace(/\.ts$/, '.js'));
        action = file.exists && build || clear;
        try {
          return (await action.call(pack, file));
        } catch (error) {
          err = error;
          log(log.red('Error while processing:'), shortPath(file.path));
          return log(err.stack);
        }
      };
      return roots.forEach(function(root) {
        return pack.stream(root, watchOptions).on('data', onChange);
      });
    }
  };
};
